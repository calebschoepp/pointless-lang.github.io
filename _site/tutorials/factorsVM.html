<!DOCTYPE html>
<html>

  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="This tutorial covers the implementation of a virtual-machine for a small, stack-based language in Pointless. We'll take an incremental approach to building the VM and improving its capabilities until it can run a short prime-factorization program. ">

  <title>Pointless: tutorials -- Writing a VM for a Small Stack-Base Language in Pointless</title>

  <link rel="stylesheet" type="text/css" href="/css/style.css">
  <link rel="stylesheet" type="text/css" href="/highlight/highlight.css">
  <link rel="stylesheet" type="text/css" href="/fonts/fonts.css">
</head>


  <body>

    <header>
  <a href="/">
    <img src="/images/pointless.png">
  </a>
</header>

    <nav>
  <a href="/"><span>HOME</span></a>
  <a href="/online"><span>ONLINE</span></a>
  <a href="/docs.html"><span>DOCS</span></a>
  <a href="/api"><span>API</span></a>
  <a href="/examples.html"><span>EXAMPLES</span></a>
  <a href="/install.html"><span>INSTALL</span></a>
  <a href="/dev.html"><span>DEVELOPMENT</span></a>
  <a href="/tutorials"><span>TUTORIALS</span></a>
</nav>


    <main>
            <h3>Tutorial: Writing a VM for a Small Stack-Base Language in Pointless</h3>
      <pre>- Avery N. Nortonsmith</pre>

      <hr>

      <p>
        The age of functional programming will soon be over.
      </p>

      <p>
        Object-oriented programming has come and gone. Functional programming -- the wise, quiet observer -- has waited patiently for its turn. But FP, like OOP, will fade away in time as software yields to the inexorable pull of the one <em>True Paradigm</em>: stack-based programming!
      </p>

      <hr>

      <p>
        Joking aside, stack-based programming <em>is</em> pretty cool.
      </p>

      <p>
        This tutorial covers the implementation of a <strong>virtual-machine</strong> for a small, <strong>stack-based</strong> language in Pointless. We'll take an <strong>incremental</strong> approach to building the VM and improving its capabilities until it can run a short <strong>prime-factorization</strong> program.
      </p>

      This project seeks to demonstrate:

      <ul style="margin-bottom: 0px;">
        <li>
          How an imperative language can be implemented in a purely functional context
        </li>

        <li>
          How to structure and refactor code that uses persistent data-structures
        </li>

        <li>
          How Pointless can -- even as a young language -- be used to solve non-trivial tasks
        </li>
      </ul>

      <p>
        Before we tackle prime-factorization, let's take a look at a small example of the stack-based code that our VM will evaluate. The following Pointless code defines a <a href="/docs.html#lists">list</a> of 'instructions', where <a href="/docs.html#tuples">labeled-tuples</a> are used to represent instructions with an argument, and <a href="/docs.html#labels">labels</a> are used for those without. A list of instructions like this represents a program in our stack-based language:
      </p>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]
</pre>
      </div>

      <p>
        Let's take a minute to fancy things up by writing a function to pretty-print these instruction lists -- this will come in handy later when we work with more complex programs. The function <code>showInst</code> below takes an instruction and returns a string showing the instruction's type (left-justified to 5 characters) and argument. The function <code>argOrBlank</code> returns an instruction's argument if there is one, or an empty string otherwise. 
      </p>

      <div class="sample">
        <pre class="highlight">
showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""
</pre>
      </div>

      <p>
        In the code above, <code><a href="/api/prelude/format.html#format">format</a></code>, <code><a href="/api/prelude/label.html#getLabel">getLabel</a></code>, <code><a href="/api/prelude/types.html#is">is</a></code>, and <code><a href="/api/prelude/label.html#unwrap">unwrap</a></code> are defined in the Pointless <a href="/api/index.html">prelude</a> (standard-library).
      </p>

      <p>
        To see our new functions in action, we'll define an output variable for our program; in Pointless, a program's output is defined by its output variable. The prelude contains functions like <code><a href="/api/prelude/io.html#printLines">printLines</a></code> which generate sequences of IO commands that can be assigned to a program's output variable.
      </p>

      <p>
        The output definition below takes our list of instructions, generates a new list of instruction-strings by calling <code>showInst</code> on each instruction, and produces IO commands to print each string on a separate line. Take a look at the docs for more info on the function <a href="/docs.html#pipeOperator">pipe operator</a> <code>|></code>, and for <a href="/docs.html#partialApplication">partial application</a>.
      </p>

      <p><em>
        Note that the name 'main.ptls' is chosen arbitrarily; it doesn't have any special meaning
      </em></p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> map(showInst)
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

[ Const ] 7
[ Const ] 2
[ Mod   ] 
[ Const ] 0
[ Eq    ] 
[ Print ] 
[ Exit  ]
</pre>
      </div>

      <p>Seeing is believing. Time to start making our VM.</p>

      <p>
        We'll represent the VM as an <a href="/docs.html#objects">object</a> with the following fields:
      </p>

      <ul>
        <li><code>slots</code>: used to store "heap" variables (discussed later on)</li>
        <li><code>insts</code>: an array containing the program's instructions</li>
        <li><code>index</code>: the position in instruction array of the current instruction</li>
        <li><code>stack</code>: a linked-list serving as the stack for the VM</li>
        <li><code>outVal</code>: used to get output from VM as program runs</li>
      </ul>

      <p>
        The function <code>vmFromInsts</code> sets up a new VM object for a given list of instructions. The code also adds the label <code>VM</code> to the VM object (objects and tuples can be labeled in Pointless). Object labels can be used to write code that tells different types of objects apart, or simply for documentation (as we do here).
      </p>

      <div class="sample">
        <pre class="highlight">
vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(program)
  index  = 0
  stack  = []
  outVal = None
}
</pre>
      </div>

      <p>
        To check that <code>vmFromInsts</code> works, we'll modify our output definition to create and print a new VM object. Note that we've replaced <code>printLines</code> with <code><a href="/api/prelude/io.html#println">println</a></code> -- <code>printLines</code> expects a sequence of values (and can print these values on-the-fly as they're computed in the case of lists!), whereas <code>println</code> can handle sequence and non-sequences types.
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> println
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = [Const(7) Const(2) Mod Const(0) Eq Print Exit]; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
</pre>
      </div>

      <p>
        We run the program, and see that <code>println</code> gives us a nice visualization of our initial VM object, fields and all.
      </p>

      <p>
        Back to our list of instructions:
      </p>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]
</pre>
      </div>

      <p>
        The instructions above do the following -- (once we've implemented them, that is):
      </p>

      <ul>
        <li><code>Const(arg)</code> pushes <code>arg</code> onto the VM stack</li>
        <li><code>Mod</code> pops values <code>v0</code> and <code>v1</code> from the stack, and pushes <code>v1 % v0</code></li>
        <li><code>Eq</code> pops values <code>v0</code> and <code>v1</code> from the stack, and pushes <code>v1 == v0</code></li>
        <li><code>Print</code> pops a value from the stack and prints it</li>
        <li><code>Exit</code> signals the end of the program</li>
      </ul>

      <p>
        Additionally, each of these instructions will advance the VM to the next instruction after performing the behaviors above. Nice and imperative ;)
      </p>

      <p>
        With this in mind, we see that the program above does the following: loads the values <code>7</code> and <code>2</code> onto the stack, computes <code>7 % 2</code>, loads the value <code>0</code>, compares <code>0</code> with the result of <code>7 % 2</code>, prints the result of this comparison, and exits. In other words, this program tells us whether or not <code>7</code> is even.
      </p>

      <p>
        Now that we've defined some instructions, let's start evaluating them.
      </p>

      <div class="sample">
        <pre class="highlight">
eval(vm) = cond {
  case is(Const, vm.insts[vm.index])
    vm with $.stack = [unwrap(vm.insts[vm.index])] ++ vm.stack
}
</pre>
      </div>

      <p>
        Our <code>eval</code> function uses a <code><a href="/docs.html#cond">cond</a></code> conditional -- eventually this will include cases for all instructions, but we'll start with just <code>Const</code> for now. The code above calls the function <code><a href="/api/prelude/types.html#is">is</a></code> to check whether the current instruction has the label <code>Const</code> (where the current instruction is the instruction in the <code>vm.insts</code> array at index <code>vm.index</code>). If <code>is</code> returns true, then conditional evaluates and returns the body of the case expression.
      </p>

      <p>
        Structures in Pointless persistent, and thus immutable. As such, our program will never mutate the state of a VM object; rather, it will produce new VM objects. The code above uses <a href="/docs.html#viaWith">with syntax</a> (which can handle both shallow and nested updates -- one of Pointless's little innovations) to create a new VM object with a new stack value: the old stack with the instruction argument pushed to the top. The <code>unwrap</code> function is used to get the argument from the <code>Const</code> instruction.
      </p>

      <p>
        The code above is dense and repetitive! We can improve it by defining a couple of variables. In the new version, <code>inst</code> is the current instruction, and the <code>arg</code> is the argument of that instruction.
      </p>

      <div class="sample">
        <pre class="highlight">
eval(vm) = cond {
  case is(Const, inst)
    vm with $.stack = [arg] ++ vm.stack

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}
</pre>
      </div>

      <p>
        We modify the program's output definition to call <code>eval</code> on the VM to evaluate the first instruction, <code>Const(7)</code>. Looking at output, we see that the value <code>7</code> has been pushed to the stack.
      </p>

      <p><em>
        <code>insts</code> field abbreviated for readability
      </em></p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> eval
  |> println
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
</pre>
      </div>

      <p>
        But wait! We need our <code>Const</code> handler to do one more thing -- advance the VM to the next instruction. To do this, we'll make a new helper function <code>advance</code> that takes a VM object and returns a new VM object with the instruction index incremented. We'll also move the code for pushing a value onto the VM stack into the new function <code>pushVal</code>.
      </p>

      <div class="sample">
        <pre class="highlight">
advance(vm) = vm with $.index += 1

pushVal(arg, vm) = vm with $.stack = [arg] ++ vm.stack
</pre>
      </div>

      <p>
        Using these two new functions, the code for <code>eval</code> becomes:
      </p>

      <div class="sample">
        <pre class="highlight">
eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
</pre>
      </div>

      <p>
        We call the program again and get the result seen above: the new VM object returned by <code>eval</code> has the value <code>7</code> on its stack and its index incremented.
      </p>

      <p>
        At this point, the entire program looks something like this:
      </p>

      <p><em>
        Note that the comment bars are not necessary, but are helpful for dividing code visually -- it's a habit of mine, like using fake em-dashes. They can also be used to mark API documentation
      </em></p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> eval
  |> println

------------------------------------------------------------------------------

program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]

------------------------------------------------------------------------------

showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""

------------------------------------------------------------------------------

vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(program)
  index  = 0
  stack  = []
  outVal = None
}

------------------------------------------------------------------------------

eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}

------------------------------------------------------------------------------

advance(vm) = vm with $.index += 1

pushVal(arg, vm) = vm with $.stack = [arg] ++ vm.stack
</pre>
      </div>

      <p>
        Let's keep going.
      </p>

      <p>
        The <code>Const</code> instruction pushes values onto the stack; other instructions will need to access and pop stack values. We introduce two new functions to help with this: <code>valAt(n, vm)</code> returns the value at depth <code>n</code> on the stack; <code>popVals(n, vm)</code> returns a VM object with the top <code>n</code> stack values removed.
      </p>

      <div class="sample">
        <pre class="highlight">
valAt(n, vm) = at(n, vm.stack)

popVals(n, vm) = vm with $.stack = drop(n, vm.stack)
</pre>
      </div>

      <p>
        We use these two functions to create a case to handle our first numerical operation, <code>Mod</code>:
      </p>

      <div class="sample">
        <pre class="highlight">
case is(Mod, inst)
  vm
  |> popVals(2)
  |> pushVal(valAt(1, vm) % valAt(0, vm))
  |> advance
</pre>
      </div>

      <p>
        The <code>Mod</code> instruction pops the top two values from the stack -- <code>v0</code> and <code>v1</code> -- and pushes the value <code>v1 % v0</code> to the stack (<code>Mod</code> expects the divisor to be at the top of the stack, and the dividend beneath it). The VM is then advanced to the next instruction.
      </p>

      <p>
        Hold up! How can we access the top two stack values after we've already popped them? To see how this works, remember that <code>popVals</code> does not modify the VM object, but rather creates a new one. Thus <code>valAt(1, vm)</code> and <code>valAt(0, vm)</code> refer to the original VM object, whose stack still contains the two values in question.
      </p>

      <p>
        To test our implementation for <code>Mod</code>, we'll comment some instructions out:
      </p>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  -- Const(0),
  -- Eq,
  -- Print,
  Exit,
]
</pre>
      </div>

      <p>
        Instead of single calling <code>eval</code> once as before, we now call <code>eval</code> repeatedly using the <code><a href="/api/prelude/function.html#iterate">iterate</a></code> function. This generates a sequence of VM objects where the first element is the initial VM object, and the following elements are the VM objects produced by each subsequent application of <code>eval</code>. We use <code><a href="/api/prelude/list.html#takeUntil">takeUntil</a></code> to get these updated VM objects until we reach the VM object with <code>Exit</code> as its current instruction. Node that the <code>Exit</code> instruction is not evaluated -- it's just there to mark the end of the program.
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(eval)
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = [2, 7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = [1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 3; outVal = None}
</pre>
      </div>

      <p>
        The lines in the result above show VM objects:
      </p>

      <ol>
        <li>In the initial VM state</li>
        <li>After running <code>Const(7)</code></li>
        <li>After running <code>Const(2)</code></li>
        <li>After running <code>Mod</code></li>
        
      </ol>

      <p>
        The stack of the final VM objects holds the value <code>1</code>, the result of <code>7 % 2</code>, as expected.
      </p>

      <p>
        We can do some copy/pasting to get a case for <code>Eq</code> that's almost identical to the handler for <code>Mod</code> -- the only difference is the <code>==</code> operator!
      </p>

      <div class="sample">
        <pre class="highlight">
case is(Eq, inst)
  vm
  |> popVals(2)
  |> pushVal(valAt(1, vm) == valAt(0, vm))
  |> advance
</pre>
      </div>

      <p>
        Unfortunately this leaves us with some duplicated code between handlers for <code>Mod</code> and <code>Eq</code>. We can improve things by factoring these handlers out into a helper function for generic binary operations. This new function, <code>binaryOp</code>, takes a binary function argument <code>op</code>, which is used to calculate the result that gets pushed to the stack.
      </p>

      <div class="sample">
        <pre class="highlight">
binaryOp(op, vm) =
 vm
 |> popVals(2)
 |> pushVal(op(valAt(0, vm), valAt(1, vm)))
 |> advance
</pre>
      </div>

      <p>
        Note that <code>v0</code> comes before <code>v1</code> in <code>binaryOp</code>.  This is done because the prelude functions that we'll pass <code>binaryOp</code> take their arguments in <em>reversed order</em> (for example the function <code><a href="/api/prelude/numerical.html#mod">mod</a></code> which wraps the operator <code>%</code>). These numerical prelude functions are designed this way with partial application in mind: it's more useful for <code>mod(2)</code> to mean <code>n => n % 2</code> instead of <code>n => 2 % n</code>. This happens to match the order that the operands will popped from the stack, so no reversal is needed.
      </p>

      <p>
        We can now rewrite the cases for <code>Mod</code> and <code>Eq</code> like this:
      </p>

      <div class="sample">
        <pre class="highlight">
case is(Mod, inst)
  vm |> binaryOp(mod)

case is(Eq, inst)
  vm |> binaryOp(eq)
</pre>
      </div>

      <p>
        At this point the <code>eval</code> function can handle all instructions in our example program except for <code>Print</code>. We'll comment out the <code>Print</code> instruction and run the program.
      </p>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  -- Print,
  Exit,
]
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = [2, 7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = [1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 3; outVal = None}
VM {stack = [0, 1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 4; outVal = None}
VM {stack = [false]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 5; outVal = None}
</pre>
      </div>

      <p>
        Our evaluation calculates <code>7 % 2</code> as before, and loads the number <code>0</code>, and compares this to the result of the modulo operation.
      </p>

      <p>
        We need one more helper function to implement the case for the <code>Print</code> instruction. Our new function <code>setOutput</code> takes an argument value and sets the <code>.outVal</code> field on the updated VM object to this value.
      </p>

      <div class="sample">
        <pre class="highlight">
setOutput(val, vm) = vm with $.outVal = val
</pre>
      </div>

      <p>
        The handler for the <code>Print</code> instruction pops a value from the stack, sets the VM <code>.outVal</code> field to this value, and advances the VM:
      </p>

      <div class="sample">
        <pre class="highlight">
case is(Print, inst)
  vm
  |> popVals(1)
  |> setOutput(valAt(0, vm))
  |> advance
</pre>
      </div>

      <p>
        Now we can update our output definition to get the output from our VM. Instead of printing the value of the VM object on each evaluation loop, we instead get the value of the <code>.outVal</code> field of each VM object using <code>map(vm => vm.outVal)</code>, and print each of these values on a new line using <code>printLines</code>. We also want to clear the <code>.outVal</code> field before each instruction runs, so we modify our call to <code>iterate</code> to call <code>setOutput(None)</code> on each VM object before calling <code>eval</code>. As before, we run the iteration loop until the <code>Exit</code> instruction is reached.
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

None
None
None
None
None
None
false
</pre>
      </div>

      <p>
        We see that numerical instructions yield no print output (<code>None</code>), while the <code>Print</code> instruction yields the output value <code>false</code> -- the result of <code>7 % 2 == 1</code>.
      </p>

      <p>
        To keep the definition for the output variable simple, we'll refactor our output code into a new function, <code>runGetOutput</code>, which takes a list of instructions, creates a new VM object, evaluates the instructions, and get the VM output.           <code>runGetOutput</code> also uses the <code><a href="/api/prelude/list.html#filter">filter</a></code> function to discard the <code>None</code> outputs that come from the non-<code>Print</code> instructions.
      </p>

      <div class="sample">
        <pre class="highlight">
runGetOutput(insts) =
  vmFromInsts(insts)
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> filter(notEq(None))
</pre>
      </div>

      <p>
        Our new output definition calls <code>runGetOutput</code> and produces the result below, which tells us that, unsurprisingly, 7 is not even.
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> runGetOutput
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

false
</pre>
      </div>

      <p>
        Here's what our current program looks like:
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> runGetOutput
  |> printLines

runGetOutput(insts) =
  vmFromInsts(insts)
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> filter(notEq(None))

------------------------------------------------------------------------------

program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]

------------------------------------------------------------------------------

showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""

------------------------------------------------------------------------------

vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(program)
  index  = 0
  stack  = []
  outVal = None
}

------------------------------------------------------------------------------

eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

  case is(Print, inst)
    vm
    |> popVals(1)
    |> setOutput(valAt(0, vm))
    |> advance

  case is(Mod, inst) vm |> binaryOp(mod)
  case is(Eq, inst)  vm |> binaryOp(eq)

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}

------------------------------------------------------------------------------

advance(vm)        = vm with $.index += 1
pushVal(arg, vm)   = vm with $.stack = [arg] ++ vm.stack
popVals(n, vm)     = vm with $.stack = drop(n, vm.stack)
setOutput(val, vm) = vm with $.outVal = val

valAt(n, vm) = at(n, vm.stack)

binaryOp(op, vm) =
 vm
 |> popVals(2)
 |> pushVal(op(valAt(0, vm), valAt(1, vm)))
 |> advance
</pre>
      </div>

      <p>
        Maybe not so Pointless after all...
      </p>
      <p>
        Let's look at our prime-factorization program:
      </p>

      <div class="sample">
        <pre class="highlight">
n = 80122

program = [
  Const(2),
  Store(0),            -- store value 2 in slot 0 (initial divisor)
  Const(n),
  Store(1),            -- store value n in slot 1 (initial dividend)
  Label("checkDone"),
  Load(1),             -- load dividend
  Const(1),
  Eq,                  -- compare dividend to value 1
  JmpIf("end"),        -- jump to end if dividend == 1
  Label("checkDiv"), 
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Mod,
  Const(0),
  Eq,                  -- compare dividend % dividor == 0 
  JmpIf("divisible"),
  Load(0),             -- load divisor
  Const(1),
  Add,                 -- increment divisor
  Store(0),            -- store new divisor
  Jmp("checkDiv"),     -- check end condition
  Label("divisible"),
  Load(0),             -- load divisor
  Print,               -- print divisor (current factor)
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Div,
  Store(1),            -- store dividend / divisor as new dividend
  Jmp("checkDone"),    -- check end condition
  Label("end"),
  Const("done"),
  Print,               -- print "done"
  Exit,
]
</pre>
      </div>

      <p>
        This program is more complex than the last; it makes use of the VM's variable slots for "long term" storage. Slots serve as the VM's "heap" and are accessed by integer "addresses" (indices). In this program, the current factor being tested (the divisor) lives in slot 0, and the current number whose factor is being calculated (the dividend) lives in slot 1.
      </p>

      <p>
        The prime-factorization program also uses some new instructions:
      </p>

      <div class="sample">
        <pre class="highlight">
Add, Div, Load, Store, Jmp, JmpIf
</pre>
      </div>

      <p>
        These instructions behave as follows:
      </p>

      <ul>
        <li>
          <code>Add</code> pops values <code>v0</code> and <code>v1</code> from the stack, pushes <code>v1 + v0</code>, and advances
        </li>

        <li>
          <code>Div</code> pops values <code>v0</code> and <code>v1</code> from the stack, pushes <code>v1 / v0</code>, and advances
         </li>

        <li>
          <code>Load(arg)</code> pushes the value in the slot at index <code>arg</code> to stack, and advances
         </li>

        <li>
          <code>Store(arg)</code> pops value <code>v0</code>, stores <code>v0</code> in the slot at index <code>arg</code>, and advances
         </li>

        <li>
          <code>Jmp(arg)</code> sets VM instruction index to <code>arg</code>
         </li>

        <li>
          <code>JmpIf(arg)</code> pops value <code>v0</code>, sets VM instruction index to <code>arg</code> if <code>v0 == true</code>, otherwise advances
         </li>
      </ul>

      <p>
        The instructions <code>Jmp</code> and <code>JmpIf</code> take numerical arguments, but in the program above they have string arguments! The program contains <code>Label</code> instructions whose argument strings mark the target locations of the corresponding jump instructions. Before evaluating our new program, we'll need to write code that converts these string jump targets into numerical indices and removes the <code>Label</code> instructions. That code starts with the following functions:
      </p>

      <div class="sample">
        <pre class="highlight">
getLabelInds(insts) =
  insts
  |> reduce(scanInst, (0, {})) -- keep track of (current index, index map)
  |> at(1) -- return index map

scanInst(pair, inst) = 
  if not is(Label, inst)
  then (ind + 1, inds)
  else (ind, newInds)
  where {
    newInds = inds with $[unwrap(inst)] = ind
    (ind, inds) = pair -- (current index, index map)
  }
</pre>
      </div>

      <p>
        <code>getLabelInds</code> uses the <code><a href="/api/prelude/list.html#reduce">reduce</a></code> function to iterate through the given instructions list while keeping track of the current index (not counting <code>Label</code> instructions)
        and maintaining a <a href="/docs.html#dicts">dict</a> matching jump target strings with instruction indices. After iterating through all of the instructions, <code>getLabelInds</code> returns this dict. 
      </p>

      <p>
        <code>scanInst</code> (called for each instruction by <code>getLabelInds</code>) takes the pair (current index, index dict) and the current instruction in the list and adds the instruction to the index dict if the instruction is a <code>Label</code>, or increments the current index otherwise.
      </p>

      <p>
        The output definition below displays the index dict calculated for the prime-factorization program instructions:
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> getLabelInds
  |> println
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

{"checkDone": 4, "divisible": 19, "checkDiv": 8, "end": 26}
</pre>
      </div>

      <p>
        To produce the instructions that the VM will run, we'll need to filter out the <code>Label</code> instructions and replace the target strings of jump instructions with indices. The function <code>convertJumps</code> does both of these things, using the index dict calculated with <code>getLabelInds</code>. To do this, <code>convertJumps</code> calls the helper function <code>convertJump</code>, which translates jump instructions using the index dict obtained from <code>getLabelInds</code>.
      </p>

      <div class="sample">
        <pre class="highlight">
convertJumps(insts) =
  insts
  |> filter(notIs(Label))
  |> map(convertJump(inds))
  where inds = getLabelInds(insts)

convertJump(inds, inst) = cond {
  case is(Jmp, inst) Jmp(inds[unwrap(inst)])
  case is(JmpIf, inst) JmpIf(inds[unwrap(inst)])
  else inst
}
</pre>
      </div>

      <p>
        To make sure our code works, we'll modify our output definition to call <code>convertJumps</code> and use the function <code>showInst</code> from before to get string representations for each resulting instruction. In addition to this, we'll call <code><a href="/api/prelude/list.html#enumerate">enumerate</a></code> to get <code>(index, value)</code> pairs for each instruction string, and call <code>format("{>2} {}")</code> on each pair to print each instruction along with its index (this helps us see where the jump instructions now point).
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> convertJumps
  |> map(showInst)
  |> enumerate
  |> map(format("{>2} {}"))
  |> printLines
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

 0 [ Const ] 2
 1 [ Store ] 0
 2 [ Const ] 80122
 3 [ Store ] 1
 4 [ Load  ] 1
 5 [ Const ] 1
 6 [ Eq    ] 
 7 [ JmpIf ] 26
 8 [ Load  ] 1
 9 [ Load  ] 0
10 [ Mod   ] 
11 [ Const ] 0
12 [ Eq    ] 
13 [ JmpIf ] 19
14 [ Load  ] 0
15 [ Const ] 1
16 [ Add   ] 
17 [ Store ] 0
18 [ Jmp   ] 8
19 [ Load  ] 0
20 [ Print ] 
21 [ Load  ] 1
22 [ Load  ] 0
23 [ Div   ] 
24 [ Store ] 1
25 [ Jmp   ] 4
26 [ Const ] done
27 [ Print ] 
28 [ Exit  ] 
</pre>
      </div>

      <p>
        Things are looking good: <code>convertJumps</code> replaced the old jump targets with indices, and removed the old <code>Label</code> instructions. Now we can update <code>vmFromInsts</code> to call <code>convertJumps</code>.
      </p>

      <div class="sample">
        <pre class="highlight">
vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(convertJumps(program))
  index  = 0
  stack  = []
  outVal = None
}
</pre>
      </div>

      <p>
        Time to implement the last few instruction handlers. We'll write the following helper methods for accessing and writing to the VM's slots: <code>load</code> pushes the value at slot index <code>arg</code> to the stack, and <code>store</code> saves the value at the top of the stack to slot index <code>arg</code>.  
      </p>

      <div class="sample">
        <pre class="highlight">
load(arg, vm) = pushVal(vm.slots[arg], vm)

store(arg, vm) = vm with $.slots[arg] = head(vm.stack)
</pre>
      </div>

      <p>
        We implement the handlers for the <code>Load</code> and <code>Store</code> instructions like this:
      </p>

      <div class="sample">
        <pre class="highlight">
case is(Load, inst)
  vm
  |> load(arg)
  |> advance

case is(Store, inst)
  vm
  |> store(arg)
  |> popVals(1)
  |> advance
</pre>
      </div>

      <p>
        Don't partial application and function piping go together so nicely?
      </p>

      <p>
        We can see this code in action using one of our previous output definitions (which shows intermediate VM states), along with a short example program:
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(eval)
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> printLines

program = [
  Const(1),
  Store(0), -- store 1 in slot 0
  Load(0),  -- load 1 from slot 0
  Const(2),
  Mul,      -- 2 * 1 = 2
  Store(1), -- store 2 in slot 1
  Load(1),  -- load 2 from slot 1
  Const(2),
  Mul,      -- 2 * 2 = 4
  Store(0), -- store 4 in slot 1
  Exit,
]
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = []; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = [1]; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 3; outVal = None}
VM {stack = [2, 1]; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 4; outVal = None}
VM {stack = [2]; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 5; outVal = None}
VM {stack = []; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 6; outVal = None}
VM {stack = [2]; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 7; outVal = None}
VM {stack = [2, 2]; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 8; outVal = None}
VM {stack = [4]; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 9; outVal = None}
VM {stack = []; insts = ...; slots = [4 2 0 0 0 0 0 0]; index = 10; outVal = None}
</pre>
      </div>

      <p>
        The results above show the <code>Load</code> and <code>Store</code> reading from and writing to the <code>.slots</code> fields of the VM objects.
      </p>

      <p>
        Our last helper function, <code>jumpIf</code>, updates the VM index to the value <code>arg</code> if the value <code>pred</code> is true, or advances the VM otherwise. 
      </p>

      <div class="sample">
        <pre class="highlight">
jumpIf(pred, arg, vm) =
  if pred
  then vm with $.index = arg
  else advance(vm)
</pre>
      </div>

      <p>
        We use <code>jumpIf</code> to implement handlers for both the <code>Jmp</code> and <code>JmpIf</code> instructions. <code>JmpIf</code> pops a value from the stack and passes it as the predicate to <code>jumpIf</code>, along with its target index (<code>arg</code>). <code>Jmp</code> also passes its target index to <code>jumpIf</code>, and passes <code>true</code> as its predicate, since <code>Jmp</code> instructions always jump.
      </p>

      <div class="sample">
        <pre class="highlight">
case is(JmpIf, inst)
  vm
  |> popVals(1)
  |> jumpIf(valAt(0, vm), arg)

case is(Jmp, inst)
  vm
  |> jumpIf(true, arg)
</pre>
      </div>

      <p>
        The following output definition and example program show <code>JmpIf</code> in action:
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(eval)
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> printLines

program = [
  Const(false),
  JmpIf("skip"), -- top-of-stack is false, don't jump 
  Const("A"),    -- loads "A"
  Const(true),
  JmpIf("skip"), -- top-of-stack is true, jump to "skip"
  Const("B"),    -- (skipped)
  Label("skip"),
  Exit,          -- exits with only "A" on the stack
]
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [false]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = []; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = ["A"]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 3; outVal = None}
VM {stack = [true, "A"]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 4; outVal = None}
VM {stack = ["A"]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 6; outVal = None}
</pre>
      </div>

      <p>
        We'll wrap things up by adding handlers for the remaining binary operations using the <code>binaryOp</code> function from before. Handlers for <code>Sub</code> and <code>Mul</code> and included for completeness.
      </p>

      <div class="sample">
        <pre class="highlight">
case is(Eq,  inst) vm |> binaryOp(eq)
case is(Add, inst) vm |> binaryOp(add)
case is(Sub, inst) vm |> binaryOp(sub)
case is(Mul, inst) vm |> binaryOp(mul)
case is(Div, inst) vm |> binaryOp(div)
case is(Mod, inst) vm |> binaryOp(mod)
</pre>
      </div>

      <p>
        We can now run the entire prime-factorization program using the output definition from before:
      </p>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> runGetOutput
  |> printLines
</pre>
      <pre class="result">
$ ./bin/pointless main.ptls

2
7
59
97
done
</pre>
      </div>

      <p>
        We did it! We implemented a VM in Pointless. And we never even mentioned monads.
      </p>

      <p>
        You can run the final prime-factorization program and VM implementation <a href="/online/factorsVM.html">online</a>. There are many numerical programs that could now be written for our VM -- see this <a href="/online/factorsVM.html">collatz sequence example</a>.
      </p>

      <p>
        Visit the <a href="dev.html">dev page</a> for instructions on installing Pointless locally. Contributions to the language and example code are welcome!
      </p>

      <p>
        Our entire program (split into several file) is shown below:
      </p>

      <div class="sample">
        <pre class="fileName">main.ptls</pre>

        <pre class="highlight">
import "stackVM.ptls" as stackVM

------------------------------------------------------------------------------

output =
  program
  |> stackVM.runGetOutput
  |> printLines

------------------------------------------------------------------------------

n = 80122

program = [
  Const(2),
  Store(0),            -- store value 2 in slot 0 (initial divisor)
  Const(n),
  Store(1),            -- store value n in slot 1 (initial dividend)
  Label("checkDone"),
  Load(1),             -- load dividend
  Const(1),
  Eq,                  -- compare dividend to value 1
  JmpIf("end"),        -- jump to end if dividend == 1
  Label("checkDiv"), 
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Mod,
  Const(0),
  Eq,                  -- compare dividend % dividor == 0 
  JmpIf("divisible"),
  Load(0),             -- load divisor
  Const(1),
  Add,                 -- increment divisor
  Store(0),            -- store new divisor
  Jmp("checkDiv"),     -- check end condition
  Label("divisible"),
  Load(0),             -- load divisor
  Print,               -- print divisor (current factor)
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Div,
  Store(1),            -- store dividend / divisor as new dividend
  Jmp("checkDone"),    -- check end condition
  Label("end"),
  Const("done"),
  Print,               -- print "done"
  Exit,
]
</pre>
      </div>

      <div class="sample">
        <pre class="fileName">stackVM.ptls</pre>

        <pre class="highlight">
export {
  runGetOutput
}

------------------------------------------------------------------------------

import "instructions.ptls" as instructions

------------------------------------------------------------------------------

vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(instructions.convertJumps(program))
  index  = 0
  stack  = []
  outVal = None
}

------------------------------------------------------------------------------

runGetOutput(insts) =
  vmFromInsts(insts)
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> filter(notEq(None))

------------------------------------------------------------------------------

eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

  case is(Print, inst)
    vm
    |> popVals(1)
    |> setOutput(valAt(0, vm))
    |> advance

  case is(Load, inst)
    vm
    |> load(arg)
    |> advance

  case is(Store, inst)
    vm
    |> store(arg)
    |> popVals(1)
    |> advance

  case is(JmpIf, inst)
    vm
    |> popVals(1)
    |> jumpIf(valAt(0, vm), arg)

  case is(Jmp, inst)
    vm
    |> jumpIf(true, arg)

  case is(Eq,  inst) vm |> binaryOp(eq)
  case is(Add, inst) vm |> binaryOp(add)
  case is(Sub, inst) vm |> binaryOp(sub)
  case is(Mul, inst) vm |> binaryOp(mul)
  case is(Div, inst) vm |> binaryOp(div)
  case is(Mod, inst) vm |> binaryOp(mod)

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}

------------------------------------------------------------------------------

advance(vm)        = vm with $.index += 1
pushVal(arg, vm)   = vm with $.stack = [arg] ++ vm.stack
popVals(n, vm)     = vm with $.stack = drop(n, vm.stack)
setOutput(val, vm) = vm with $.outVal = val
store(arg, vm)     = vm with $.slots[arg] = head(vm.stack)
load(arg, vm)      = pushVal(vm.slots[arg], vm)

jumpIf(pred, arg, vm) =
  if pred
  then vm with $.index = arg
  else advance(vm) 

valAt(n, vm) = at(n, vm.stack)

binaryOp(op, vm) =
 vm
 |> popVals(2)
 |> pushVal(op(valAt(0, vm), valAt(1, vm)))
 |> advance
</pre>
      </div>

      <div class="sample">
        <pre class="fileName">instructions.ptls</pre>

        <pre class="highlight">
export {
  showInst, makeInstArray
}

------------------------------------------------------------------------------

showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""

------------------------------------------------------------------------------

convertJumps(insts) =
  insts
  |> filter(notIs(Label))
  |> map(convertJump(inds))
  where inds = getLabelInds(insts)

------------------------------------------------------------------------------

convertJump(inds, inst) = cond {
  case is(Jmp, inst) Jmp(inds[unwrap(inst)])
  case is(JmpIf, inst) JmpIf(inds[unwrap(inst)])
  else inst
}

------------------------------------------------------------------------------

getLabelInds(insts) =
  insts
  |> reduce(scanInst, (0, {})) -- keep track of (current index, index map)
  |> at(1) -- return index map

------------------------------------------------------------------------------

scanInst(pair, inst) = 
  if not is(Label, inst)
  then (ind + 1, inds)
  else (ind, newInds)
  where {
    newInds = inds with $[unwrap(inst)] = ind
    (ind, inds) = pair -- (current index, index map)
  }
</pre>
      </div>
    </main>

    <footer>
  <div>copyright (c) 2020 Avery N. Nortonsmith (averynortonsmith@fastmail.com)</div>
<div>logo based on <a href="http://www.figlet.org/fontdb_example.cgi?font=isometric1.flf">isometric1</a> by Kent Nassen</div>
<div>code color scheme based on Mariana from <a href="https://www.sublimetext.com/">Sublime Text</a></div>

</footer>

    <script src="/highlight/js/highlightGen.js"></script>
<script src="/highlight/js/highlight.js"></script>

<script async defer data-domain="ptls.dev" src="https://plausible.io/js/plausible.js"></script>

  </body>
</html>
